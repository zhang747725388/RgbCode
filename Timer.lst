C51 COMPILER V9.01   TIMER                                                                 04/28/2016 00:05:31 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN Timer.obj
COMPILER INVOKED BY: C:\keil51\C51\BIN\C51.EXE BSP\Timer.c BROWSE INCDIR(.\APP;.\BSP;..\..\CodeGroup;..\rgbcode) DEBUG O
                    -BJECTEXTEND PRINT(.\Timer.lst) OBJECT(Timer.obj)

line level    source

   1          /*************  功能说明        **************
   2           
   3          
   4          ******************************************/
   5          
   6          
   7          
   8          #include "rsystem.h"
   9          INT32U  r_tickcnt;       
  10          u8 uiflag=0;
  11          /********************* Timer0中断函数************************/
  12          void timer0_int (void) interrupt TIMER0_VECTOR
  13          {
  14   1              static INT32U tickcnt = 0;
  15   1                      static INT32U Autocnt = 0;
  16   1              if ( ++tickcnt >= RML_SYSTICK_TIME )
  17   1              {
  18   2                tickcnt = 0;
  19   2                 Autocnt++;
  20   2                r_tickcnt++;
  21   2      //              PrintString1("Init UART1...\r\n");      //SUART1发送一个字符串
  22   2              
  23   2                      if(r_tickcnt>6553){
  24   3                 
  25   3                                r_tickcnt=0;
  26   3                        } 
  27   2              }
  28   1                 if(OpenFlag==1){
  29   2                               SwitchModel();
*** WARNING C206 IN LINE 29 OF BSP\TIMER.C: 'SwitchModel': missing function-prototype
  30   2                    switch(AutoFlag){
  31   3                        case  0:  
  32   3                              break;
  33   3                         case  1:
  34   3                                      if(Autocnt>100){
  35   4                                                 modelflag++;
  36   4                                                 if(modelflag>8){
  37   5                                                 
  38   5                                                 modelflag=0; 
  39   5                                                 }
  40   4                                Autocnt=0;
  41   4                        } 
  42   3                              break;
  43   3                        }
  44   2                      
  45   2                 }
  46   1              
  47   1      
  48   1                       
  49   1      }
  50          
  51          /********************* Timer1中断函数************************/
  52          void timer1_int (void) interrupt TIMER1_VECTOR
  53          {
C51 COMPILER V9.01   TIMER                                                                 04/28/2016 00:05:31 PAGE 2   

  54   1       
  55   1               
  56   1      //        DaswitchFlags=!DaswitchFlags;
  57   1      //        if(SwitchDavalue(DaswitchFlags))
  58   1      //      {
  59   1      //              TH1 = (u8)(PWM_high1 >> 8);     //如果是输出低电平，则装载高电平时间。
  60   1      //              TL1 = (u8)PWM_high1;
  61   1      //   
  62   1      //    
  63   1      //      }
  64   1      // 
  65   1      //      else    {
  66   1      //              TH1 =  (u8)(PWM_low1 >> 8);     //如果是输出高电平，则装载低电平时间。
  67   1      //              TL1 = (u8)PWM_low1;
  68   1      //       uiflag++;
  69   1      //      }
  70   1      //     switch(uiflag){
  71   1      //        case 0:
  72   1      //                  TLC5620_SetOutput(1, 19)  ; break;
  73   1      //        case 1:
  74   1      //                  TLC5620_SetOutput(1, 19)  ; break;
  75   1      //      case 2:
  76   1      //                  TLC5620_SetOutput(1, 19)  ; break;
  77   1      //        case 3:
  78   1      //                  TLC5620_SetOutput(1, 19)  ; break;
  79   1      //        case 4:
  80   1      //                  TLC5620_SetOutput(1, 19)  ;         break;
  81   1      //      case 5:
  82   1      //                  TLC5620_SetOutput(1, 19)  ;         break;
  83   1      //        case 6:
  84   1      //                  TLC5620_SetOutput(1, 19)  ;         break;
  85   1      //        case 7:
  86   1      //                  TLC5620_SetOutput(1, 19)  ;         break;   
  87   1      //      case 8:
  88   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
  89   1      //        
  90   1      //      case 9:
  91   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
  92   1      //        case 10:
  93   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
  94   1      //      case 11:
  95   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
  96   1      //       
  97   1      //         case 12:
  98   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
  99   1      //       
 100   1      //         case 13:
 101   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
 102   1      //       
 103   1      //         case 14:
 104   1      //                  TLC5620_SetOutput(1, 82)  ;         break;
 105   1      //       
 106   1      //         case 15:
 107   1      //                  TLC5620_SetOutput(1, 82)  ; uiflag=0;       break;
 108   1      //        
 109   1      //       }
 110   1      
 111   1      }
 112          
 113           
 114          /************************ 定时器配置 ****************************/
 115          void    Timer_config(void)
C51 COMPILER V9.01   TIMER                                                                 04/28/2016 00:05:31 PAGE 3   

 116          {
 117   1              
 118   1              TIM_InitTypeDef         TIM_InitStructure1;                                     //结构定义
 119   1              TIM_InitTypeDef         TIM_InitStructure;                                      //结构定义
 120   1              TIM_InitStructure.TIM_Mode      = TIM_16Bit;    //指定工作模式,   TIM_16BitAutoReload,TIM_16Bit,TIM_8BitAuto
             -Reload,TIM_16BitAutoReloadNoMask
 121   1              TIM_InitStructure.TIM_Polity    = PolityHigh;                   //指定中断优先级, PolityHigh,PolityLow
 122   1              TIM_InitStructure.TIM_Interrupt = ENABLE;                               //中断是否允许,   ENABLE或DISABLE
 123   1              TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_12T;                        //指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK
             -_Ext
 124   1              TIM_InitStructure.TIM_ClkOut    = DISABLE;                              //是否输出高速脉冲, ENABLE或DISABLE
 125   1              TIM_InitStructure.TIM_Value     = 65536UL - PWM_HIGH_MIN;       //初值,
 126   1              TIM_InitStructure.TIM_Run       = ENABLE;                               //是否初始化后启动定时器, ENABLE或DISABLE
 127   1              Timer_Inilize(Timer0,&TIM_InitStructure);                               //初始化Timer0    Timer0,Timer1,Timer2
 128   1      //      
 129   1      //      
 130   1              
 131   1              
 132   1      //      TIM_InitStructure1.TIM_Mode      = TIM_16Bit;   //指定工作模式,   TIM_16BitAutoReload,TIM_16Bit,TIM_8Bit
             -AutoReload,TIM_16BitAutoReloadNoMask
 133   1      //      TIM_InitStructure1.TIM_Polity    = PolityLow;                   //指定中断优先级, PolityHigh,PolityLow
 134   1      //      TIM_InitStructure1.TIM_Interrupt = ENABLE;                              //中断是否允许,   ENABLE或DISABLE
 135   1      //      TIM_InitStructure1.TIM_ClkSource = TIM_CLOCK_12T;                       //指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CL
             -OCK_Ext
 136   1      //      TIM_InitStructure1.TIM_ClkOut    = DISABLE;                             //是否输出高速脉冲, ENABLE或DISABLE
 137   1      //      TIM_InitStructure1.TIM_Value     = 65536UL - PWM_HIGH_MIN1;     //初值,
 138   1      //      TIM_InitStructure1.TIM_Run       = ENABLE;                              //是否初始化后启动定时器, ENABLE或DISABLE
 139   1      //      Timer_Inilize(Timer1,&TIM_InitStructure1);                              //初始化Timer0    Timer0,Timer1,Timer2
 140   1      //      
 141   1        
 142   1      }
*** WARNING C280 IN LINE 118 OF BSP\TIMER.C: 'TIM_InitStructure1': unreferenced local variable
 143          
 144          //========================================================================
 145          // 函数: u8     Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 146          // 描述: 定时器初始化程序.
 147          // 参数: TIMx: 结构参数,请参考timer.h里的定义.
 148          // 返回: 成功返回0, 空操作返回1,错误返回2.
 149          // 版本: V1.0,  
 150          //========================================================================
 151          u8      Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 152          {
 153   1              if(TIM > Timer2)        return 1;       //空操作
 154   1      
 155   1              if(TIM == Timer0)
 156   1              {
 157   2                      TR0 = 0;                //停止计数
 158   2                      if(TIMx->TIM_Interrupt == ENABLE)               ET0 = 1;        //允许中断
 159   2                      else                                                                    ET0 = 0;        //禁止中断
 160   2                      if(TIMx->TIM_Polity == PolityHigh)              PT0 = 1;        //高优先级中断
 161   2                      else                                                                    PT0 = 0;        //低优先级中断
 162   2                      if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2;       //错误
 163   2                      TMOD = (TMOD & ~0x03) | TIMx->TIM_Mode; //工作模式,0: 16位自动重装, 1: 16位定时/计数, 2: 8位自动重装, 3:
             - 16位自动重装, 不可屏蔽中断
 164   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)        AUXR &= ~0x80;  //12T
 165   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         AUXR |=  0x80;  //1T
 166   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        TMOD |=  0x04;  //对外计数或分频
 167   2                      else                                                                            TMOD &= ~0x04;  //定时
 168   2                      if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;      //输出时钟
 169   2                      else                                                    INT_CLKO &= ~0x01;      //不输出时钟
 170   2                      
 171   2                      TH0 = (u8)(TIMx->TIM_Value >> 8);
C51 COMPILER V9.01   TIMER                                                                 04/28/2016 00:05:31 PAGE 4   

 172   2                      TL0 = (u8)TIMx->TIM_Value;
 173   2                      if(TIMx->TIM_Run == ENABLE)     TR0 = 1;        //开始运行
 174   2      
 175   2                      return  0;              //成功
 176   2              }
 177   1      
 178   1      if(TIM == Timer1)
 179   1              {
 180   2                      TR1 = 0;                //停止计数
 181   2                      if(TIMx->TIM_Interrupt == ENABLE)               ET1 = 1;        //允许中断
 182   2                      else                                                                    ET1 = 0;        //禁止中断
 183   2                      if(TIMx->TIM_Polity == PolityHigh)              PT1 = 1;        //高优先级中断
 184   2                      else                                                                    PT1 = 0;        //低优先级中断
 185   2                      if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2;       //错误
 186   2                      TMOD = (TMOD & ~0x30) | TIMx->TIM_Mode; //工作模式,0: 16位自动重装, 1: 16位定时/计数, 2: 8位自动重装
 187   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)        AUXR &= ~0x40;  //12T
 188   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         AUXR |=  0x40;  //1T
 189   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        TMOD |=  0x40;  //对外计数或分频
 190   2                      else                                                                            TMOD &= ~0x40;  //定时
 191   2                      if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;      //输出时钟
 192   2                      else                                                    INT_CLKO &= ~0x02;      //不输出时钟
 193   2                      
 194   2                      TH1 = (u8)(TIMx->TIM_Value >> 8);
 195   2                      TL1 = (u8)TIMx->TIM_Value;
 196   2                      if(TIMx->TIM_Run == ENABLE)     TR1 = 1;        //开始运行
 197   2                      return  0;              //成功
 198   2              }
 199   1      
 200   1              if(TIM == Timer2)               //Timer2,固定为16位自动重装, 中断无优先级
 201   1              {
 202   2                      AUXR &= ~(1<<4);        //停止计数
 203   2                      if(TIMx->TIM_Interrupt == ENABLE)                       IE2  |=  (1<<2);        //允许中断
 204   2                      else                                                                            IE2  &= ~(1<<2);        //禁止中断
 205   2                      if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)        return 2;
 206   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)        AUXR &= ~(1<<2);        //12T
 207   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)         AUXR |=  (1<<2);        //1T
 208   2                      if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)        AUXR |=  (1<<3);        //对外计数或分频
 209   2                      else                                                                            AUXR &= ~(1<<3);        //定时
 210   2                      if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;      //输出时钟
 211   2                      else                                                    INT_CLKO &= ~0x04;      //不输出时钟
 212   2      
 213   2                      TH2 = (u8)(TIMx->TIM_Value >> 8);
 214   2                      TL2 = (u8)TIMx->TIM_Value;
 215   2                      if(TIMx->TIM_Run == ENABLE)     AUXR |=  (1<<4);        //开始运行
 216   2                      return  0;              //成功
 217   2              }
 218   1              return 2;       //错误
 219   1      }
 220          
 221          void Timer_Set(SYSTIMER *timer, INT32U alarm_time)
 222          {
 223   1              timer->start_cnt = r_tickcnt;
 224   1              timer->alarm_time = alarm_time; 
 225   1      }
 226          
 227          
 228          INT32U Timer_GetElapse(SYSTIMER *timer)
 229          {
 230   1              return  (r_tickcnt - timer->start_cnt) * RML_SYSTICK_TIME; 
 231   1      }
 232          void Timer_Reset(SYSTIMER *timer)
 233          {
C51 COMPILER V9.01   TIMER                                                                 04/28/2016 00:05:31 PAGE 5   

 234   1              
 235   1              timer->start_cnt = r_tickcnt=0;
 236   1       
 237   1      }
 238          
 239           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    646    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
